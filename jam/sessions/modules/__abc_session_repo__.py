# -*- coding: utf-8 -*-

from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import Any, Optional
from uuid import uuid4

from cryptography.fernet import Fernet


class BaseSessionModule(ABC):
    """Abstract base class for session management modules.

    Methods:
        id (str): Returns a unique ID generated by the id_factory.
        create(session_key: str, data: dict): Creates a new session with the given session key and data.
        get(session_key: Optional[str], session_id: Optional[str]): Retrieves a session by its key or ID.
        delete(session_key: Optional[str], session_id: Optional[str]): Deletes a session by its key or ID.
        update(session_id: str, data: dict): Updates an existing session with new data.
        rework(session_id: str): Reworks a session and returns its new ID.
        clear(session_key: str): Clears all sessions by key.
    """

    def __init__(
        self,
        id_factory: Callable[[], str] = lambda: str(uuid4()),
        is_session_key_crypt: bool = False,
        session_key_aes_secret: Optional[bytes] = None,
    ) -> None:
        """Class constructor.

        Args:
            id_factory (Callable[str], optional): A callable that generates unique IDs. Defaults to a UUID factory.
            is_session_key_crypt (bool, optional): If True, session keys will be encoded. Defaults to False.
            session_key_aes_secret (Optional[bytes], optional): AES secret for encoding session keys.
        """
        self._id = id_factory
        self._sk_mark_symbol = "J$_"
        if is_session_key_crypt and not session_key_aes_secret:
            raise ValueError(
                "If 'code_session_key' is True, 'session_key_aes_secret' must be provided."
            )
        if is_session_key_crypt:
            self._code_session_key = Fernet(session_key_aes_secret)

    def _encode_session_id(self, data: str) -> str:
        """Encode the session using AES encryption."""
        if not hasattr(self, "_code_session_key"):
            raise AttributeError("Session key encoding is not enabled.")
        return f"{self._sk_mark_symbol}{self._code_session_key.encrypt(data.encode()).decode()}"

    def _decode_session_id(self, data: str) -> str:
        """Decode the session using AES decryption."""
        if not hasattr(self, "_code_session_key"):
            raise AttributeError("Session key encoding is not enabled.")
        if not data.startswith(self._sk_mark_symbol):
            raise ValueError("Session key is not encoded or is invalid.")
        return self._code_session_key.decrypt(
            data[len(self._sk_mark_symbol) :].encode()
        ).decode()

    @property
    def id(self) -> str:
        """Return the unique ID use id_factory."""
        return self._id()

    @abstractmethod
    def create(self, session_key: str, data: dict) -> None:
        """Create a new session with the given session key and data.

        Args:
            session_key (str): The key for the session.
            data (dict): The data to be stored in the session.
        """
        raise NotImplementedError

    @abstractmethod
    def get(self, session_id: str) -> Any:
        """Retrieve a session by its key or ID.

        Args:
            session_id (str): The ID of the session.

        Returns:
            Any: The session data if found, otherwise None.
        """
        raise NotImplementedError

    @abstractmethod
    def delete(self, session_id: str) -> None:
        """Delete a session by its key or ID.

        Args:
            session_id (str): The ID of the session.
        """
        raise NotImplementedError

    @abstractmethod
    def update(self, session_id: str, data: dict) -> None:
        """Update an existing session with new data.

        Args:
            session_id (str): The ID of the session to update.
            data (dict): The new data to be stored in the session.
        """
        raise NotImplementedError

    @abstractmethod
    def rework(self, session_id: str) -> str:
        """Rework a session and return its new ID.

        Args:
            session_id (str): The ID of the session to rework.

        Returns:
            str: The new session ID.
        """
        raise NotImplementedError

    @abstractmethod
    def clear(self, session_key: str) -> None:
        """Clear all sessions by key.

        Args:
            session_key (str): The key for the sessions to clear.
        """
        raise NotImplementedError
